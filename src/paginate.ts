#!/usr/bin/env node
/** vim: set syntax=typescript tabstop=2 softtabstop=2 shiftwidth=2 expandtab smarttab : */

/**
 * Semi-Automated or manually-configurable pagination for AWS API calls
 *
 * @remarks
 * THIS MODULE IS DEPRECATED BY `get-aws-results`
 *
 * This module makes use only of AWS SDKv2 Promises, but uses as much information as possible
 * from the SDK to attempt to automatically paginate API calls using an async generator.
 * It also provides the means to automatically paginate based on manually-provided values
 * for the inputToken, outputToken and resultKey parameters.
 *
 * This has been deprecated by a new approach in get-aws-results that uses the automatic
 * pagination capabilities of the AWS SDKv2 that are hidden beneath the surface, using
 * event listeners on AWS Request objects to recursively request additional pages.
 *
 * @deprecated by get-aws-results
 * @module
 */

'use strict';

import * as AWS from 'aws-sdk';

export interface PaginatableResult {
  paginationTokenValueFromResultsPage?: string;
  resultsFromPage: any;
  moreResultsValue?: string | undefined;
}

export type PaginatableFunction = (paginationTokenValueForRequest: string | undefined) => Promise<PaginatableResult>;

/**
 * Pagination implementation function for paginating AWS API Call results
 *
 * @remarks
 * A helper function for getting paginated results from
 * AWS API calls. Most APIs return a maximum number of results,
 * and a pagination token to allow to you make another call for
 * the next set of results until no results remain.
 * Additionally many APIs use different parameters for the pagination
 * token such as nextToken or NextToken.
 * This function allows us to make a generic API call, defining the correct
 * pagination token for the API call, and retrieving all of the results
 *
 * @example
 * ```js
 * const AWS = require('aws-sdk');
 * const client = new AWS.<client name>({<params>})();          // e.g. Organizations
 * const operation = '<operation name>'                         // e.g. listAccounts
 * paginationSettings = {
 *   inputToken: <the inputToken for the Operation>,            // e.g. NextToken
 *   outputToken: <the outputToken for the Operation>,          // e.g. NextToken
 *   resultKey: <the resultKey for the Operation>,              // e.g. Accounts
 *   moreResults: <Optional moreResults key for the Operation>, // e.g. IsTruncated
 * }
 * const res = await getPaginatedResults(async (paginationTokenValueForRequest) => {
 *   const operationParams = Object.assign({ [paginationSettings.inputToken]: paginationTokenValueForRequest }, params);
 *   //console.log(`Paginating\n\tclient: ${client.api.serviceId}\n\toperation: ${operation}\n\tparams: ${JSON.stringify(operationParams, null, 2)}\n\tpaginationSettings: ${JSON.stringify(paginationSettings, null, 2)}`);
 *   const page = await client[operation](operationParams).promise();
 *
 *   return {
 *     paginationTokenValueFromResultsPage: page[paginationSettings.outputToken],
 *     resultsFromPage: page[paginationSettings.resultKey],
 *     moreResults: paginationSettings.moreResults ? page[paginationSettings.moreResults] : undefined,
 *   };
 * });
 * return { [paginationSettings.resultKey]: res };
 * ```
 *
 * @param awsApiCallerFunction - An async function, per the example, handling paginationTokenValueForRequest, and returning paginationTokenValueFromResultsPage, resultsFromPage, moreResults, to be called by this generator so as to yield a concatenation of all of the resultsFromPage
 * @returns A promise to generate the concatenated results from each page generated by the function provided
 * @public
 */
export const getPaginatedResults = async (awsApiCallerFunction: PaginatableFunction): Promise<Array<any>> => {
  const concatenatedResultsPages: Array<unknown> = [];

  for await (const lf of (async function* generateResultsFromFunction() {
    let paginationTokenValueForRequest: string | undefined;
    let continueLoop = false;
    let firstLoop = true;

    /**
     * After the first loop that follows initialisation of continueLoop with EMPTY
     * So long as contineLoop was set to something, i.e. not undefined, in the previous loop, continue.
     */
    while (firstLoop || continueLoop) {
      firstLoop = false;

      /**
       * requestPaginationTokenValue will be sent into the awsApiCallerFunction as paginationTokenValueForRequest
       * which will be used to create the operation parameters: `{[inputToken]: paginationTokenValueForRequest}`
       * If continueLoop is EMPTY, we are on our first loop, therefore set it to undefined, which the API
       * operation will accept and ignore; otherwise we are in a repeat of the loop in which case we need the
       * value to come from the output of the previous loop - i.e. the NEW value of paginationTokenValueForRequest
       * which was originally EMPTY, but now we are past the first loop it is no longer EMPTY.
       * This will never be symbol('EMPTY') but it must be a permitted type as we are assigning
       * paginationTokenValueForRequest which is a `<string | symbol>`
       */
      const requestPaginationTokenValue: string | undefined = firstLoop ? undefined : paginationTokenValueForRequest;

      /**
       * Call and await the PaginatableFunction "awsApiCallerFunction" we were passed as a parameter.
       * Give it the parameter "requestPaginationTokenValue" which will be either:
       *   * undefined in the first loop
       *   * string from a previous loop
       *
       * Destructure the PaginatableResult into constituent parts
       */
      const { paginationTokenValueFromResultsPage, resultsFromPage, moreResultsValue }: PaginatableResult =
        await awsApiCallerFunction(requestPaginationTokenValue).catch((error: unknown) => {
          throw error;
        });
      if (!resultsFromPage) {
        throw new Error("Your function isn't working properly! No resultsFromPage to yield");
      }

      /**
       * We have successfully made our API calls and got our results
       * Yield the results
       */
      yield* resultsFromPage;

      /** Define our settings for controlling the loop iteration */
      /** paginationTokenValueForRequest, if defined, will be used as the inputToken Value in the next API call */
      paginationTokenValueForRequest = paginationTokenValueFromResultsPage;

      /**
       * continueLoop is how we know if we are the last set of results.
       * We may or may not be using/accepting moreResults, depending on the pagination configuration
       *   * if we have received a moreResults value and it's valid, then that's enough for us,
       *     set it as continueLoop which will allow another loop iteration
       *   * if moreResults is undefined, we can still use the outputToken value
       *     that the results page from the API gave us. Use the outputToken Value
       *     and send it into the loop condition, where if it is set to something
       *     the loop will continue, and if it is not, we must be all finished.
       */
      if (moreResultsValue && moreResultsValue !== 'false' && moreResultsValue !== 'False') {
        continueLoop = true;
      } else {
        continueLoop = !!paginationTokenValueFromResultsPage;
      }
    }
  })()) {
    /**
     * We're all done yielding from our generator, push the resultsFromPage
     * into our concatenatedResultsPages Array that we will return inside a promise.
     */
    concatenatedResultsPages.push(lf);
  }

  /** All done! */
  return concatenatedResultsPages;
};

/**
 * An interface defining the settings required to automatically paginate AWS Results
 *
 * @public
 */
export interface PaginationSettings {
  /** String-indexed */
  [index: string]: any;

  /* The token passed into an AWS Request identifying the token to begin a results page from */
  inputToken: string;
  /* The token returned in an AWS Response identifying the start of the next page of results */
  outputToken: string;
  /* The key containing the results of the operation in the AWS response that can be concatenated to provide an Array of all results from all pages */
  resultKey: string;
  /* A boolean provided by some AWS Services that indicates whather or not a further page of results is available */
  moreResults?: string;
}

/**
 * A special object passed into the paginate function that contains all the information
 * about the request and the API object to use so that the request may be made and
 * automatically paginated if possible
 *
 * @public
 */
export interface PaginationConfig {
  /** An AWS Service object */
  client: any;
  /** The operation to call from the service */
  operation: string;
  /** Parameters to pass to the operation */
  params?: any;
  /** Whether to attempt to automatically paginate results */
  paginate?: boolean;
  /** PaginationSettings to use for the automatic pagination */
  paginationSettings?: PaginationSettings;
}

/**
 * A wrapper function for getPaginatedResults to simplify and standardise paginated AWS API calls
 *
 * @remarks
 * A function to make use of getPaginatedResults in a simple to use
 * and standardised way. It accepts a configuration containing the
 * AWS API Service and Operation to call, as well as optionally custom
 * operation parameters, and custom pagination settings and tries to
 * return paginated results for the call, either using the settings
 * provided or automatically via information ascertained from the
 * AWS API; or unpaginated if instructed or unable.
 *
 * @example
 * ```js
 * const aws = require('aws-sdk');
 * const paginationConfig = {
 *   client: new aws.<aws service>(<{params}>), // e.g. Route53
 *   operation: '<operation>',                  // e.g. listHostedZones
 *   paginationSettings: {
 *     inputToken: '<operation input token>',   // e.g. NextToken
 *     outputToken: '<operation output token>', // e.g. NextToken
 *     resultKey: '<operation result key>',     // e.g. HostedZones
 *   },
 * };
 * const results = await paginate(paginationConfig);
 * console.log(JSON.stringify(results, null, 2));
 * ```
 *
 * @param config - The pagination config Object, containing the AWS Service Interface object, the operation to perform and optional parameters and pagination settings
 * @returns A promise to return the AWS API call results, either constructed through pagination or generated as a single call to the API
 * @public
 */
export const paginate = async (config: PaginationConfig): Promise<any> => {
  try {
    const { client, operation } = config;
    const params = config.params || {};

    let { paginationSettings } = config;

    if (!(operation in client['api']['operations'])) {
      throw new Error(
        `Invalid Operation. SDK does not support operation ${operation} for service ${client['api']['serviceId']}`,
      );
    }

    const validatePaginationProperties = (paginationSettingsToValidate: PaginationSettings): boolean => {
      /**
       * The paginator *must* have these properties and they must be
       * simple strings if we have any hope of automagical pagination
       */
      const requiredPaginationProperties = ['inputToken', 'outputToken', 'resultKey'];

      if (
        requiredPaginationProperties.every((paginationProperty) => {
          if (paginationProperty in paginationSettingsToValidate) {
            const property = paginationSettingsToValidate[paginationProperty];
            if (property !== undefined && typeof property === 'string' && property.match(/^[A-Za-z]+$/)) {
              /** Return a truthy value if the property value is a nice, simple string */
              return paginationProperty;
            }
          }

          /** One or more of our require properties weren't present or weren't nice simple strings */
          return undefined;
        })
      ) {
        return true;
      }
      return false;
    };

    /** If we've bee told not to paginate, don't paginate */
    let wePaginate: boolean = config.paginate !== false;

    if (wePaginate) {
      /** No pagination was explicitly specified or we were asked to paginate */

      if (!paginationSettings) {
        /** No pagination paginationSettings specified, attempt automatic pagination */

        /** Get the apiOperation Model from the AWS SDK */
        const apiOperation = client['api']['operations'][operation];

        if (apiOperation['paginator']) {
          /** If the SDK provides pagination information for the Operation, try to use it */
          wePaginate = validatePaginationProperties(apiOperation['paginator']);
          if (wePaginate) {
            paginationSettings = apiOperation['paginator'];
          }
        } else {
          /** Automatic Pagination not possible due to missing API information */
          wePaginate = false;
        }
      } else {
        /** Manual Pagination has been requested by specifying config['paginationSettings'] */
        wePaginate = validatePaginationProperties(paginationSettings);
      }
    }

    if (wePaginate) {
      if (!paginationSettings) {
        throw new Error('Pagination Settings expected but not found');
      }

      const {
        inputToken,
        outputToken,
        resultKey,
        moreResults,
      }: { inputToken: string; outputToken: string; resultKey: string; moreResults?: string | undefined } =
        paginationSettings;

      const res: Array<any> = await getPaginatedResults(async (paginationTokenValueForRequest: string | undefined) => {
        const operationParams: any = {
          [inputToken]: paginationTokenValueForRequest,
          ...params,
        };
        /** console.log(`Paginating\n\tclient: ${client['api']['serviceId']}\n\toperation: ${operation}\n\tparams: ${JSON.stringify(operationParams, null, 2)}\n\tpaginationSettings: ${JSON.stringify(paginationSettings, null, 2)}`); */
        const page: any = await client[operation](operationParams).promise();

        return {
          paginationTokenValueFromResultsPage: page[outputToken],
          resultsFromPage: page[resultKey],
          moreResults: moreResults ? page[moreResults] : undefined,
        };
      }).catch((error: unknown) => {
        throw error;
      });

      return { [resultKey]: res };
    }
    /** console.log(`Not Paginating\n\tclient: ${client.api.serviceId}\n\toperation: ${operation}\n\tparams: ${JSON.stringify(params, null, 2)} :: paginationSettings: ${JSON.stringify(paginationSettings, null, 2)}`); */
    const result = await client[operation](params)
      .promise()
      .catch((error: unknown) => {
        throw error;
      });
    return result;
  } catch (error) {
    throw error;
  }
};

/**
 * Common private function for CLI process failure
 *
 * @param error - A thrown Exception or error string
 * @returns nothing
 * @internal
 */
const _die = (error: unknown) => {
  console.error(error);
  process.exit(1);
};

/**
 * An example invocation of the paginate function that can be run from the CLI
 *
 * @returns An empty promise
 * @internal
 */
const example = async (): Promise<void> => {
  const paginationConfig: PaginationConfig = {
    client: new AWS.Route53(),
    operation: 'listHostedZones',
    paginationSettings: {
      inputToken: 'NextToken',
      outputToken: 'NextToken',
      resultKey: 'HostedZones',
    },
  };

  const results: Map<string, AWS.Route53.HostedZones> = await paginate(paginationConfig).catch((error: unknown) => {
    throw error;
  });
  console.log(JSON.stringify(results, null, 2));
};

/** If executing from the CLI, run the example function */
if (require.main === module) {
  example().catch((error: unknown) => {
    _die(error);
  });
}
